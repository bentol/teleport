/*
Copyright 2017 Gravitational, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package auth

import (
	"crypto/tls"
	"net"
	"time"

	"github.com/gravitational/teleport"
	authority "github.com/gravitational/teleport/lib/auth/testauthority"
	"github.com/gravitational/teleport/lib/backend"
	"github.com/gravitational/teleport/lib/backend/dir"
	"github.com/gravitational/teleport/lib/events"
	"github.com/gravitational/teleport/lib/limiter"
	"github.com/gravitational/teleport/lib/services"
	"github.com/gravitational/teleport/lib/services/local"
	"github.com/gravitational/teleport/lib/services/suite"
	"github.com/gravitational/teleport/lib/session"
	"github.com/gravitational/teleport/lib/utils"

	"github.com/gravitational/trace"
)

// TestAuthServerConfig is auth server test config
type TestAuthServerConfig struct {
	// ClusterName is cluster name
	ClusterName string
	// Dir is a directory for local backend
	Dir string
}

// CheckAndSetDefaults checks and sets defaults
func (cfg *TestAuthServerConfig) CheckAndSetDefaults() error {
	if cfg.ClusterName == "" {
		cfg.ClusterName = "localhost"
	}
	if cfg.Dir == "" {
		return trace.BadParameter("missing parameter Dir")
	}
	return nil
}

// TestAuthServer is auth server using local filesystem backend
// and test certificate authority key generation that speeds up
// keygen by using the same private key
type TestAuthServer struct {
	TestAuthServerConfig
	// AuthServer is auth server
	AuthServer *AuthServer
	// AuditLog is events audit log
	AuditLog events.IAuditLog
	// SessionLogger is a session logger
	SessionServer session.Service
	// Backend is backend for auth server
	Backend backend.Backend
	// Authorizer is authorizer used in tests
	Authorizer Authorizer
}

// NewTestAuthServer returns new instance of Auth server
func NewTestAuthServer(cfg TestAuthServerConfig) (*TestAuthServer, error) {
	if err := cfg.CheckAndSetDefaults(); err != nil {
		return nil, trace.Wrap(err)
	}
	srv := &TestAuthServer{
		TestAuthServerConfig: cfg,
	}
	var err error
	srv.Backend, err = dir.New(backend.Params{"path": cfg.Dir})
	if err != nil {
		return nil, trace.Wrap(err)
	}

	srv.AuditLog, err = events.NewAuditLog(events.AuditLogConfig{
		DataDir: cfg.Dir, RecordSessions: true})
	if err != nil {
		return nil, trace.Wrap(err)
	}

	srv.SessionServer, err = session.New(srv.Backend)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	access := local.NewAccessService(srv.Backend)
	identity := local.NewIdentityService(srv.Backend)

	srv.AuthServer = NewAuthServer(&InitConfig{
		Backend:   srv.Backend,
		Authority: authority.New(),
		Access:    access,
		Identity:  identity,
	})

	// set cluster config
	clusterConfig, err := services.NewClusterConfig(services.ClusterConfigSpecV3{
		SessionRecording: services.RecordAtNode,
	})
	if err != nil {
		return nil, trace.Wrap(err)
	}
	err = srv.AuthServer.SetClusterConfig(clusterConfig)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	// set cluster name
	clusterName, err := services.NewClusterName(services.ClusterNameSpecV2{
		ClusterName: srv.ClusterName,
	})
	if err != nil {
		return nil, trace.Wrap(err)
	}
	err = srv.AuthServer.SetClusterName(clusterName)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	// set static tokens
	staticTokens, err := services.NewStaticTokens(services.StaticTokensSpecV2{
		StaticTokens: []services.ProvisionToken{},
	})
	if err != nil {
		return nil, trace.Wrap(err)
	}
	err = srv.AuthServer.SetStaticTokens(staticTokens)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	// create the default role
	err = srv.AuthServer.UpsertRole(services.NewAdminRole(), backend.Forever)
	if err != nil {
		return nil, trace.Wrap(err)
	}
	// set up host private key and certificate
	srv.AuthServer.UpsertCertAuthority(suite.NewTestCA(services.HostCA, srv.ClusterName))
	if err != nil {
		return nil, trace.Wrap(err)
	}

	srv.Authorizer, err = NewAuthorizer(srv.AuthServer.Access, srv.AuthServer.Identity, srv.AuthServer.Trust)
	if err != nil {
		return nil, trace.Wrap(err)
	}
	return srv, nil
}

// NewCertificate returns new TLS client identity credentials generated by the
// test auth server
func (a *TestAuthServer) NewCertificate(identity TestIdentity) (*tls.Certificate, error) {
	switch id := identity.I.(type) {
	case LocalUser:
		user, err := a.AuthServer.GetUser(id.Username)
		if err != nil {
			return nil, trace.Wrap(err)
		}
		roles, err := services.FetchRoles(user.GetRoles(), a.AuthServer, user.GetTraits())
		if err != nil {
			return nil, trace.Wrap(err)
		}
		if identity.TTL == 0 {
			identity.TTL = time.Hour
		}
		a.AuthServer.generateUserCert(certRequest{
			user:  user,
			roles: roles,
			ttl:   identity.TTL,
		})
	case BuiltinRole:
		keys, err := a.AuthServer.GenerateServerKeys(id.Username, id.Username, teleport.Roles{id.Role})
		if err != nil {
			return nil, trace.Wrap(err)
		}
	default:
		return nil, trace.BadParameter("identity of unknown type is unsupported")
	}
}

// NewTestTLSServer returns new test TLS server
func (a *TestAuthServer) NewTestTLSServer() (*TestTLSServer, error) {
	apiConfig := &APIConfig{
		AuthServer:     a.AuthServer,
		Authorizer:     a.Authorizer,
		SessionService: a.SessionServer,
		AuditLog:       a.AuditLog,
	}

	srv, err := NewTestTLSServer(TestTLSServerConfig{
		APIConfig:  apiConfig,
		AuthServer: a.AuthServer,
	})
	if err != nil {
		return nil, trace.Wrap(err)
	}
	return srv, nil
}

// TestTLSServerConfig is a configuration for test TLS server
type TestTLSServerConfig struct {
	APIConfig  *APIConfig
	AuthServer *AuthServer
	Limiter    *limiter.LimiterConfig
	Listener   net.Listener
}

// TestTLSServer is a test TLS server
type TestTLSServer struct {
	// TestTLSServerConfig is a configuration
	TestTLSServerConfig
	// Identity is generated TLS/SSH identity used to answer in TLS
	Identity *Identity
	// TLSServer is configured TLS server
	TLSServer *TLSServer
}

// CheckAndSetDefaults checks and sets limiter defaults
func (cfg *TestTLSServerConfig) CheckAndSetDefaults() error {
	if cfg.APIConfig == nil {
		return trace.BadParameter("missing parameter APIConfig")
	}
	if cfg.AuthServer == nil {
		return trace.BadParameter("missing parameter AuthServer")
	}
	// use very permissive limiter configuration by default
	if cfg.Limiter == nil {
		cfg.Limiter = &limiter.LimiterConfig{
			MaxConnections:   1000,
			MaxNumberOfUsers: 1000,
		}
	}
	return nil
}

// NewTestTLSServer returns new test TLS server that is started and is litening
// on 127.0.0.1 loopback on any available port
func NewTestTLSServer(cfg TestTLSServerConfig) (*TestTLSServer, error) {
	err := cfg.CheckAndSetDefaults()
	if err != nil {
		return nil, trace.Wrap(err)
	}
	srv := &TestTLSServer{
		TestTLSServerConfig: cfg,
	}
	srv.Identity, err = NewServerIdentity(srv.AuthServer, "test-tls-server", teleport.RoleAuth)
	if err != nil {
		return nil, trace.Wrap(err)
	}
	// Register TLS endpoint of the auth service
	tlsConfig, err := srv.Identity.TLSConfig()
	if err != nil {
		return nil, trace.Wrap(err)
	}
	srv.TLSServer, err = NewTLSServer(TLSServerConfig{
		TLS:           tlsConfig,
		APIConfig:     *srv.APIConfig,
		LimiterConfig: *srv.Limiter,
	})
	if err != nil {
		return nil, trace.Wrap(err)
	}
	if err := srv.Start(); err != nil {
		return nil, trace.Wrap(err)
	}
	return srv, nil
}

// TestIdentity is a test identity spec
// used to generate identities in tests
type TestIdentity struct {
	I   interface{}
	TTL time.Duration
}

// NewClient returns new client to the test server authenticated with identity
func (t *TestTLSServer) NewClient(identity TestIdentity) (*Client, error) {
	tlsConfig, err := t.Identity.TLSConfig()
	if err != nil {
		return nil, trace.Wrap(err)
	}
	addrs := []utils.NetAddr{{
		AddrNetwork: t.Listener.Addr().Network(),
		Addr:        t.Listener.Addr().String()}}
	// nop identity means that the client is not authenticated
	if identity.I == nil {
		tlsConfig.Certificates = nil
		return NewTLSClient(addrs, tlsConfig)
	}
	switch id := identity.I.(type) {
	case LocalUser:
		user, err := t.AuthServer.GetUser(id.Username)
		if err != nil {
			return nil, trace.Wrap(err)
		}
		roles, err := services.FetchRoles(user.GetRoles(), t.AuthServer, user.GetTraits())
		if err != nil {
			return nil, trace.Wrap(err)
		}
		if identity.TTL == 0 {
			identity.TTL = time.Hour
		}
		t.AuthServer.generateUserCert(certRequest{
			user:  user,
			roles: roles,
			ttl:   identity.TTL,
		})
	case BuiltinRole:
		keys, err := t.AuthServer.GenerateServerKeys(id.Username, id.Username, []teleport.Roles{id.Role})
		if err != nil {
			return nil, trace.Wrap(err)
		}
	}
}

// Addr returns address of this server
func (t *TestTLSServer) Addr() string {
	return t.Listener.Addr().String()
}

// Start starts TLS server on loppback address on the first lisenting socket
func (t *TestTLSServer) Start() error {
	var err error
	if t.Listener == nil {
		t.Listener, err = net.Listen("tcp", "127.0.0.1:0")
		if err != nil {
			return trace.Wrap(err)
		}
	}
	go t.TLSServer.Serve(t.Listener)
	return nil
}

// Close closes the listener and HTTP server
func (t *TestTLSServer) Close() error {
	err := t.TLSServer.Close()
	if t.Listener != nil {
		t.Listener.Close()
	}
	return err
}

// NewServerIdentity generates new server identity, used in tests
func NewServerIdentity(authServer *AuthServer, hostID string, role teleport.Role) (*Identity, error) {
	keys, err := authServer.GenerateServerKeys(hostID, hostID, teleport.Roles{teleport.RoleAuth})
	if err != nil {
		return nil, trace.Wrap(err)
	}
	return ReadIdentityFromKeyPair(keys.Key, keys.Cert, keys.TLSCert, keys.TLSCACerts[0])
}
